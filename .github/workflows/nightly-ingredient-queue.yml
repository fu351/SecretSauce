name: Nightly Ingredient Queue

on:
  workflow_call:
    inputs:
      queue_batch_limit:
        description: "Queue batch size"
        required: false
        type: string
        default: "100"
      queue_context:
        description: "Standardizer context"
        required: false
        type: string
        default: "pantry"
      queue_resolver_name:
        description: "Resolver run name"
        required: false
        type: string
        default: "nightly-openai"
      queue_source:
        description: "Queue source filter (scraper|recipe|any)"
        required: false
        type: string
        default: "scraper"
      queue_review_mode:
        description: "Queue review mode (ingredient|unit|any)"
        required: false
        type: string
        default: "ingredient"
      queue_retry_failed:
        description: "Retry failed rows by re-queuing them to pending between batches"
        required: false
        type: string
        default: "false"
      queue_dry_run:
        description: "true/false dry run"
        required: false
        type: string
        default: "false"
      queue_enable_unit_resolution:
        description: "Enable unit resolver writes"
        required: false
        type: string
        default: "true"
      queue_unit_min_confidence:
        description: "Minimum confidence required for unit writes"
        required: false
        type: string
        default: "0.75"
      openai_model:
        description: "OpenAI model"
        required: false
        type: string
        default: "gpt-4o-mini"
      gemini_model:
        description: "Gemini model"
        required: false
        type: string
        default: "gemini-3-flash-preview"
      queue_max_batches:
        description: "Maximum batch cycles to run"
        required: false
        type: string
        default: "10"
      queue_batch_delay_seconds:
        description: "Delay between batches in seconds"
        required: false
        type: string
        default: "2"
  workflow_dispatch:
    inputs:
      queue_batch_limit:
        description: "Queue batch size"
        required: false
        type: string
        default: "100"
      queue_context:
        description: "Standardizer context"
        required: false
        type: choice
        options:
          - pantry
          - recipe
        default: pantry
      queue_resolver_name:
        description: "Resolver run name"
        required: false
        type: string
        default: "nightly-openai"
      queue_source:
        description: "Queue source filter"
        required: false
        type: choice
        options:
          - scraper
          - recipe
          - any
        default: scraper
      queue_review_mode:
        description: "Queue review mode"
        required: false
        type: choice
        options:
          - ingredient
          - unit
          - any
        default: ingredient
      queue_retry_failed:
        description: "Retry failed rows between batches"
        required: false
        type: choice
        options:
          - "false"
          - "true"
        default: "false"
      queue_dry_run:
        description: "Dry run mode"
        required: false
        type: choice
        options:
          - "false"
          - "true"
        default: "false"
      queue_enable_unit_resolution:
        description: "Enable unit resolver writes"
        required: false
        type: choice
        options:
          - "false"
          - "true"
        default: "true"
      queue_unit_min_confidence:
        description: "Minimum confidence required for unit writes"
        required: false
        type: string
        default: "0.75"
      openai_model:
        description: "OpenAI model"
        required: false
        type: string
        default: "gpt-4o-mini"
      gemini_model:
        description: "Gemini model"
        required: false
        type: string
        default: "gemini-3-flash-preview"
      queue_max_batches:
        description: "Maximum batch cycles to run"
        required: false
        type: string
        default: "10"
      queue_batch_delay_seconds:
        description: "Delay between batches in seconds"
        required: false
        type: string
        default: "2"

jobs:
  resolve-ingredient-match-queue:
    name: Resolve Ingredient Match Queue
    runs-on: ubuntu-latest
    timeout-minutes: 40
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
      QUEUE_BATCH_LIMIT: ${{ inputs.queue_batch_limit }}
      QUEUE_STANDARDIZER_CONTEXT: ${{ inputs.queue_context }}
      QUEUE_RESOLVER_NAME_BASE: ${{ inputs.queue_resolver_name }}
      QUEUE_SOURCE: ${{ inputs.queue_source }}
      QUEUE_REVIEW_MODE: ${{ inputs.queue_review_mode }}
      QUEUE_RETRY_FAILED: ${{ inputs.queue_retry_failed }}
      DRY_RUN: ${{ inputs.queue_dry_run }}
      QUEUE_ENABLE_UNIT_RESOLUTION: ${{ inputs.queue_enable_unit_resolution }}
      QUEUE_UNIT_DRY_RUN: ${{ inputs.queue_dry_run }}
      QUEUE_UNIT_MIN_CONFIDENCE: ${{ inputs.queue_unit_min_confidence }}
      OPENAI_MODEL: ${{ inputs.openai_model }}
      GEMINI_MODEL: ${{ inputs.gemini_model }}
      QUEUE_MAX_BATCHES: ${{ inputs.queue_max_batches }}
      QUEUE_BATCH_DELAY_SECONDS: ${{ inputs.queue_batch_delay_seconds }}

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: scripts/package-lock.json

      - name: Install dependencies
        run: npm install --legacy-peer-deps --prefix scripts

      - name: Expose scripts dependencies to shared imports
        run: ln -sfn "$GITHUB_WORKSPACE/scripts/node_modules" "$GITHUB_WORKSPACE/node_modules"

      - name: Queue Summary (Before)
        env:
          SUPABASE_URL: ${{ env.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ env.SUPABASE_SERVICE_KEY }}
        run: |
          echo "=== Queue Status (Before) ==="
          RESULT=$(curl -sf \
            "${SUPABASE_URL}/rest/v1/ingredient_match_queue?select=source,status&limit=10000" \
            -H "apikey: ${SUPABASE_SERVICE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}")

          echo "$RESULT" | jq 'group_by(.source, .status) | map({source: .[0].source, status: .[0].status, count: length})'
          PENDING=$(echo "$RESULT" | jq '[.[] | select(.status == "pending")] | length')
          echo "Pending rows (sampled <= 10k): $PENDING"

      - name: Resolve pending ingredient matches (Batched)
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ env.SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ env.SUPABASE_SERVICE_KEY }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ env.SUPABASE_SERVICE_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: ${{ env.OPENAI_MODEL }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_MODEL: ${{ env.GEMINI_MODEL }}
          QUEUE_BATCH_LIMIT: ${{ env.QUEUE_BATCH_LIMIT }}
          QUEUE_STANDARDIZER_CONTEXT: ${{ env.QUEUE_STANDARDIZER_CONTEXT }}
          DRY_RUN: ${{ env.DRY_RUN }}
          QUEUE_SOURCE: ${{ env.QUEUE_SOURCE }}
          QUEUE_REVIEW_MODE: ${{ env.QUEUE_REVIEW_MODE }}
          QUEUE_RETRY_FAILED: ${{ env.QUEUE_RETRY_FAILED }}
          QUEUE_ENABLE_UNIT_RESOLUTION: ${{ env.QUEUE_ENABLE_UNIT_RESOLUTION }}
          QUEUE_UNIT_DRY_RUN: ${{ env.QUEUE_UNIT_DRY_RUN }}
          QUEUE_UNIT_MIN_CONFIDENCE: ${{ env.QUEUE_UNIT_MIN_CONFIDENCE }}
          NODE_ENV: production
          SUPABASE_URL: ${{ env.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ env.SUPABASE_SERVICE_KEY }}
          QUEUE_MAX_BATCHES: ${{ env.QUEUE_MAX_BATCHES }}
          QUEUE_BATCH_DELAY_SECONDS: ${{ env.QUEUE_BATCH_DELAY_SECONDS }}
          QUEUE_RESOLVER_NAME_BASE: ${{ env.QUEUE_RESOLVER_NAME_BASE }}
        run: |
          set -euo pipefail

          max_batches="$QUEUE_MAX_BATCHES"
          delay_seconds="$QUEUE_BATCH_DELAY_SECONDS"

          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY_RUN=true -> forcing max_batches=1"
            max_batches="1"
          fi

          if [ "${QUEUE_REVIEW_MODE}" != "ingredient" ]; then
            if [ "${QUEUE_ENABLE_UNIT_RESOLUTION}" != "true" ]; then
              echo "QUEUE_REVIEW_MODE=${QUEUE_REVIEW_MODE} requires unit resolution; forcing QUEUE_ENABLE_UNIT_RESOLUTION=true"
              QUEUE_ENABLE_UNIT_RESOLUTION="true"
            fi

            if [ "${DRY_RUN}" != "true" ] && [ "${QUEUE_UNIT_DRY_RUN}" = "true" ]; then
              echo "QUEUE_REVIEW_MODE=${QUEUE_REVIEW_MODE} cannot run with QUEUE_UNIT_DRY_RUN=true in non-dry runs; forcing QUEUE_UNIT_DRY_RUN=false"
              QUEUE_UNIT_DRY_RUN="false"
            fi
          fi

          echo "Effective queue flags: review_mode=${QUEUE_REVIEW_MODE}, enable_unit_resolution=${QUEUE_ENABLE_UNIT_RESOLUTION}, unit_dry_run=${QUEUE_UNIT_DRY_RUN}, dry_run=${DRY_RUN}"

          retry_failed() {
            if [ "$QUEUE_RETRY_FAILED" != "true" ]; then
              return 0
            fi

            if [ "$DRY_RUN" = "true" ]; then
              echo "QUEUE_RETRY_FAILED=true ignored because DRY_RUN=true"
              return 0
            fi

            local query="status=eq.failed"
            if [ "${QUEUE_SOURCE}" != "any" ]; then
              query="${query}&source=eq.${QUEUE_SOURCE}"
            fi

            if [ "${QUEUE_REVIEW_MODE}" = "ingredient" ]; then
              query="${query}&needs_ingredient_review=is.true"
            elif [ "${QUEUE_REVIEW_MODE}" = "unit" ]; then
              query="${query}&needs_unit_review=is.true"
            fi

            local payload
            payload='{"status":"pending","resolved_by":null,"resolved_at":null,"processing_started_at":null,"processing_lease_expires_at":null,"last_error":"Retry requested by nightly workflow"}'

            local response
            response=$(curl -sf -X PATCH \
              "${SUPABASE_URL}/rest/v1/ingredient_match_queue?${query}&select=id" \
              -H "apikey: ${SUPABASE_SERVICE_KEY}" \
              -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}" \
              -H "Content-Type: application/json" \
              -H "Prefer: return=representation" \
              -d "${payload}")

            local retried
            retried=$(echo "$response" | jq 'length')
            echo "Requeued failed rows for retry: ${retried} (source=${QUEUE_SOURCE}, review_mode=${QUEUE_REVIEW_MODE})"
          }

          for batch in $(seq 1 "$max_batches"); do
            resolver_name="${QUEUE_RESOLVER_NAME_BASE}-b${batch}"
            echo "=== Queue Batch ${batch}/${max_batches} (resolver=${resolver_name}) ==="
            retry_failed

            QUEUE_RESOLVER_NAME="$resolver_name" QUEUE_MAX_CYCLES="1" npm --prefix scripts run resolve-ingredient-match-queue

            CLAIM_FILTER=""
            if [ "${QUEUE_REVIEW_MODE}" = "ingredient" ]; then
              CLAIM_FILTER="&needs_ingredient_review=is.true"
            elif [ "${QUEUE_REVIEW_MODE}" = "unit" ]; then
              CLAIM_FILTER="&needs_unit_review=is.true"
            fi

            if [ "${QUEUE_SOURCE}" = "any" ]; then
              PENDING_RESULT=$(curl -sf \
                "${SUPABASE_URL}/rest/v1/ingredient_match_queue?select=id,status&status=eq.pending${CLAIM_FILTER}&limit=10000" \
                -H "apikey: ${SUPABASE_SERVICE_KEY}" \
                -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}")
            else
              PENDING_RESULT=$(curl -sf \
                "${SUPABASE_URL}/rest/v1/ingredient_match_queue?select=id,status,source&status=eq.pending&source=eq.${QUEUE_SOURCE}${CLAIM_FILTER}&limit=10000" \
                -H "apikey: ${SUPABASE_SERVICE_KEY}" \
                -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}")
            fi
            PENDING_COUNT=$(echo "$PENDING_RESULT" | jq 'length')
            echo "Pending claimable rows after batch ${batch} (source=${QUEUE_SOURCE}, review_mode=${QUEUE_REVIEW_MODE}, sampled <= 10k): ${PENDING_COUNT}"

            if [ "$PENDING_COUNT" -eq 0 ]; then
              echo "Queue drained. Stopping early."
              break
            fi

            if [ "$batch" -lt "$max_batches" ]; then
              sleep "$delay_seconds"
            fi
          done

      - name: Queue Summary (After)
        env:
          SUPABASE_URL: ${{ env.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ env.SUPABASE_SERVICE_KEY }}
        run: |
          echo "=== Queue Status (After) ==="
          RESULT=$(curl -sf \
            "${SUPABASE_URL}/rest/v1/ingredient_match_queue?select=source,status&limit=10000" \
            -H "apikey: ${SUPABASE_SERVICE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}")

          echo "$RESULT" | jq 'group_by(.source, .status) | map({source: .[0].source, status: .[0].status, count: length})'
          PENDING=$(echo "$RESULT" | jq '[.[] | select(.status == "pending")] | length')
          echo "Pending rows (sampled <= 10k): $PENDING"
