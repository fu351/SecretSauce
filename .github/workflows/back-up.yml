name: Backup & Reset Ingredient Ecosystem

on:
  workflow_dispatch:
    inputs:
      action:
        description: "Action to perform"
        required: true
        type: choice
        options:
          - backup-only
          - backup-and-reset
          - restore
        default: backup-only
      run_initiating_workflow:
        description: "Run full initiating workflow after backup-and-reset"
        required: false
        type: boolean
        default: false
      initiating_mode:
        description: "Initiating mode (full, pre-queue only, or pre-queue dry-run only)"
        required: false
        type: choice
        options:
          - full
          - queue-only-no-scrape
          - queue-dry-run-only
        default: full
      initiating_store_limit:
        description: "Store limit per brand for full initiating workflow (0 = all, 5 = 5 Target + 5 Trader Joe's + ...)"
        required: false
        type: string
        default: "5"
      restore_suffix:
        description: "Backup suffix to restore (e.g., 20260209_150000)"
        required: false
        type: string
        default: ""
      confirm_reset:
        description: "Type RESET to confirm destructive action"
        required: false
        type: string
        default: ""

jobs:
  run:
    name: "${{ inputs.action }}"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
    steps:
      - name: Validate inputs
        run: |
          ACTION="${{ inputs.action }}"
          CONFIRM="${{ inputs.confirm_reset }}"
          SUFFIX="${{ inputs.restore_suffix }}"
          RUN_INITIATING="${{ inputs.run_initiating_workflow }}"
          INITIATING_MODE="${{ inputs.initiating_mode }}"
          INITIATING_STORE_LIMIT="${{ inputs.initiating_store_limit }}"

          if [[ "$ACTION" != "backup-only" && "$CONFIRM" != "RESET" ]]; then
            echo "âŒ Type RESET in the confirm field for destructive actions."
            exit 1
          fi

          if [[ "$RUN_INITIATING" == "true" && "$ACTION" != "backup-and-reset" ]]; then
            echo "âŒ Initiating workflow can only run with backup-and-reset action."
            exit 1
          fi

          if [[ "$INITIATING_MODE" == "queue-dry-run-only" && "$RUN_INITIATING" != "true" ]]; then
            echo "âŒ queue-dry-run-only mode requires run_initiating_workflow=true."
            exit 1
          fi

          if [[ "$INITIATING_MODE" == "queue-only-no-scrape" && "$RUN_INITIATING" != "true" ]]; then
            echo "âŒ queue-only-no-scrape mode requires run_initiating_workflow=true."
            exit 1
          fi

          if [[ "$ACTION" == "restore" && -z "$SUFFIX" ]]; then
            echo "âŒ Provide a backup suffix for restore."
            exit 1
          fi

          if ! [[ "$INITIATING_STORE_LIMIT" =~ ^[0-9]+$ ]]; then
            echo "âŒ initiating_store_limit must be a non-negative integer (got: $INITIATING_STORE_LIMIT)"
            exit 1
          fi

          echo "âœ… Validated: $ACTION"
          if [[ "$ACTION" == "backup-and-reset" ]]; then
            echo "âš ï¸  Queue will be wiped as part of reset"
          fi
          if [[ "$RUN_INITIATING" == "true" ]]; then
            echo "âš ï¸  Initiating workflow will run after reset"
            echo "âš™ï¸  Initiating store_limit per brand: ${INITIATING_STORE_LIMIT}"
          fi
          if [[ "$INITIATING_MODE" == "queue-dry-run-only" ]]; then
            echo "âš ï¸  Initiating mode: queue dry-run only (skip scraper + post queue)"
          fi
          if [[ "$INITIATING_MODE" == "queue-only-no-scrape" ]]; then
            echo "âš ï¸  Initiating mode: pre-queue only (skip scraper + post queue)"
          fi

      - name: Wipe Ingredient Match Queue
        if: ${{ inputs.action == 'backup-and-reset' }}
        run: |
          echo "=== Wiping Ingredient Match Queue (part of backup-and-reset) ==="

          # Get count before wipe
          BEFORE=$(curl -sI \
            "${SUPABASE_URL}/rest/v1/ingredient_match_queue?select=id" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Prefer: count=exact" \
            -H "Range: 0-0" \
            | grep -i '^content-range' \
            | sed -E 's/.*\/([0-9]+).*/\1/' || echo "0")

          echo "Rows before wipe: ${BEFORE}"

          # Delete all rows (id is UUID, so use not.is.null instead of numeric comparisons)
          curl -sf -X DELETE \
            "${SUPABASE_URL}/rest/v1/ingredient_match_queue?id=not.is.null" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Prefer: return=minimal"

          # Get count after wipe
          AFTER=$(curl -sI \
            "${SUPABASE_URL}/rest/v1/ingredient_match_queue?select=id" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Prefer: count=exact" \
            -H "Range: 0-0" \
            | grep -i '^content-range' \
            | sed -E 's/.*\/([0-9]+).*/\1/' || echo "0")

          echo "Rows after wipe: ${AFTER}"
          echo "âœ… Deleted: $((BEFORE - AFTER)) rows"

      - name: "Run: ${{ inputs.action }}"
        run: |
          set -euo pipefail

          ACTION="${{ inputs.action }}"
          SUFFIX="${{ inputs.restore_suffix }}"

          if [[ "$ACTION" == "restore" ]]; then
            PAYLOAD="{\"p_action\": \"${ACTION}\", \"p_restore_suffix\": \"${SUFFIX}\"}"
          else
            PAYLOAD="{\"p_action\": \"${ACTION}\"}"
          fi

          echo "ðŸš€ Calling fn_ingredient_ecosystem with action: $ACTION"

          RESPONSE=$(curl -sfS -X POST "${SUPABASE_URL}/rest/v1/rpc/fn_ingredient_ecosystem" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")

          echo "$RESPONSE" | jq '.' 2>/dev/null || echo "$RESPONSE"

          ACTION_RESULT=$(echo "$RESPONSE" | jq -r '.action' 2>/dev/null)
          if [[ "$ACTION_RESULT" != "$ACTION" ]]; then
            echo "âŒ Unexpected response"
            exit 1
          fi

          echo ""
          echo "âœ… $ACTION complete"
          SUFFIX_OUT=$(echo "$RESPONSE" | jq -r '.suffix // empty' 2>/dev/null)
          if [[ -n "$SUFFIX_OUT" ]]; then
            echo "ðŸ“¦ Backup suffix: $SUFFIX_OUT"
          fi

      - name: Queue Status Summary
        if: ${{ always() }}
        run: |
          echo "=== Ingredient Match Queue Status ==="

          # Optimized: Use count queries with minimal data fetch
          get_count() {
            local filter="$1"
            curl -sI \
              "${SUPABASE_URL}/rest/v1/ingredient_match_queue?select=id&${filter}" \
              -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
              -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
              -H "Prefer: count=exact" \
              -H "Range: 0-0" \
              | grep -i '^content-range' \
              | sed -E 's/.*\/([0-9]+).*/\1/' || echo "0"
          }

          echo "Status breakdown by source:"
          for source in scraper recipe; do
            for status in pending processing success failed; do
              count=$(get_count "source=eq.${source}&status=eq.${status}")
              [ "$count" != "0" ] && echo "  ${source}/${status}: ${count}"
            done
          done

          # Total pending count
          pending_total=$(get_count "status=eq.pending")
          echo "Total pending rows: ${pending_total}"

  initiating-bootstrap:
    name: Full Bootstrap (Initiating Workflow)
    needs: run
    if: ${{ inputs.action == 'backup-and-reset' && inputs.run_initiating_workflow && inputs.initiating_mode == 'full' }}
    uses: ./.github/workflows/initiating-workflow.yml
    secrets: inherit
    with:
      queue_resolver_name: "backup-initiating"
      scraper_cities_csv: "San Francisco,Oakland,Berkeley"
      scraper_state: "CA"
      ingredient_limit: "0"
      store_limit: ${{ inputs.initiating_store_limit || '5' }}
      queue_batch_limit: "100"
      queue_max_batches: "10"

  seed-mock-recipes-for-queue-modes:
    name: Seed Mock Recipes (Queue-Only Modes)
    needs: run
    if: ${{ inputs.action == 'backup-and-reset' && inputs.run_initiating_workflow && (inputs.initiating_mode == 'queue-only-no-scrape' || inputs.initiating_mode == 'queue-dry-run-only') }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
      SECRET_SEED_AUTHOR_ID: ${{ secrets.SUPABASE_SEED_AUTHOR_ID }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: scripts/package-lock.json

      - name: Install dependencies
        timeout-minutes: 15
        run: npm install --legacy-peer-deps --prefix scripts

      - name: Expose scripts dependencies to shared imports
        run: ln -sfn "$GITHUB_WORKSPACE/scripts/node_modules" "$GITHUB_WORKSPACE/node_modules"

      - name: Resolve seed author id
        run: |
          set -euo pipefail

          AUTHOR_ID="${SECRET_SEED_AUTHOR_ID// /}"

          if [ -z "$AUTHOR_ID" ]; then
            echo "No SUPABASE_SEED_AUTHOR_ID secret found. Querying earliest profile id..."
            RESPONSE=$(curl -sfS \
              "${SUPABASE_URL}/rest/v1/profiles?select=id&order=created_at.asc&limit=1" \
              -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
              -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}")

            AUTHOR_ID=$(echo "$RESPONSE" | jq -r '.[0].id // empty')
          fi

          if [ -z "$AUTHOR_ID" ]; then
            echo "âŒ Could not resolve a seed author id. Set SUPABASE_SEED_AUTHOR_ID secret or create a profile."
            exit 1
          fi

          echo "SUPABASE_SEED_AUTHOR_ID=$AUTHOR_ID" >> "$GITHUB_ENV"
          echo "âœ… Using seed author id: $AUTHOR_ID"

      - name: Seed mock recipes
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          set -euo pipefail
          ./scripts/node_modules/.bin/tsx scripts/seed-mock-recipes.ts

  initiating-queue-dry-run:
    name: Queue Dry-Run Only (No Scraper, No Post Queue)
    needs:
      - run
      - seed-mock-recipes-for-queue-modes
    if: ${{ inputs.action == 'backup-and-reset' && inputs.run_initiating_workflow && inputs.initiating_mode == 'queue-dry-run-only' }}
    uses: ./.github/workflows/nightly-ingredient-queue.yml
    secrets: inherit
    with:
      queue_batch_limit: "100"
      queue_context: "recipe"
      queue_source: recipe
      queue_resolver_name: "backup-initiating-pre-dryrun"
      queue_dry_run: "true"
      openai_model: gpt-4o-mini
      gemini_model: gemini-3-flash-preview
      queue_max_batches: "10"
      queue_batch_delay_seconds: "2"

  initiating-queue-only:
    name: Pre-Queue Only (No Scraper, No Post Queue)
    needs:
      - run
      - seed-mock-recipes-for-queue-modes
    if: ${{ inputs.action == 'backup-and-reset' && inputs.run_initiating_workflow && inputs.initiating_mode == 'queue-only-no-scrape' }}
    uses: ./.github/workflows/nightly-ingredient-queue.yml
    secrets: inherit
    with:
      queue_batch_limit: "100"
      queue_context: "recipe"
      queue_source: recipe
      queue_resolver_name: "backup-initiating-pre"
      queue_dry_run: "false"
      openai_model: gpt-4o-mini
      gemini_model: gemini-3-flash-preview
      queue_max_batches: "10"
      queue_batch_delay_seconds: "2"
