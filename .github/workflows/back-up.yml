name: Backup & Reset Ingredient Ecosystem

on:
  workflow_dispatch:
    inputs:
      action:
        description: "Action to perform"
        required: true
        type: choice
        options:
          - backup-only
          - backup-and-reset
          - restore
        default: backup-only
      run_initiating_workflow:
        description: "Run full initiating workflow after backup-and-reset"
        required: false
        type: boolean
        default: false
      restore_suffix:
        description: "Backup suffix to restore (e.g., 20260209_150000)"
        required: false
        type: string
        default: ""
      confirm_reset:
        description: "Type RESET to confirm destructive action"
        required: false
        type: string
        default: ""

jobs:
  run:
    name: "${{ inputs.action }}"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
    steps:
      - name: Validate inputs
        run: |
          ACTION="${{ inputs.action }}"
          CONFIRM="${{ inputs.confirm_reset }}"
          SUFFIX="${{ inputs.restore_suffix }}"
          RUN_INITIATING="${{ inputs.run_initiating_workflow }}"

          if [[ "$ACTION" != "backup-only" && "$CONFIRM" != "RESET" ]]; then
            echo "âŒ Type RESET in the confirm field for destructive actions."
            exit 1
          fi

          if [[ "$RUN_INITIATING" == "true" && "$ACTION" != "backup-and-reset" ]]; then
            echo "âŒ Initiating workflow can only run with backup-and-reset action."
            exit 1
          fi

          if [[ "$ACTION" == "restore" && -z "$SUFFIX" ]]; then
            echo "âŒ Provide a backup suffix for restore."
            exit 1
          fi

          echo "âœ… Validated: $ACTION"
          if [[ "$ACTION" == "backup-and-reset" ]]; then
            echo "âš ï¸  Queue will be wiped as part of reset"
          fi
          if [[ "$RUN_INITIATING" == "true" ]]; then
            echo "âš ï¸  Initiating workflow will run after reset"
          fi

      - name: Wipe Ingredient Match Queue
        if: ${{ inputs.action == 'backup-and-reset' }}
        run: |
          echo "=== Wiping Ingredient Match Queue (part of backup-and-reset) ==="

          # Get count before wipe
          BEFORE=$(curl -sI \
            "${SUPABASE_URL}/rest/v1/ingredient_match_queue?select=id" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Prefer: count=exact" \
            -H "Range: 0-0" \
            | grep -i '^content-range' \
            | sed -E 's/.*\/([0-9]+).*/\1/' || echo "0")

          echo "Rows before wipe: ${BEFORE}"

          # Delete all rows (id is UUID, so use not.is.null instead of numeric comparisons)
          curl -sf -X DELETE \
            "${SUPABASE_URL}/rest/v1/ingredient_match_queue?id=not.is.null" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Prefer: return=minimal"

          # Get count after wipe
          AFTER=$(curl -sI \
            "${SUPABASE_URL}/rest/v1/ingredient_match_queue?select=id" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Prefer: count=exact" \
            -H "Range: 0-0" \
            | grep -i '^content-range' \
            | sed -E 's/.*\/([0-9]+).*/\1/' || echo "0")

          echo "Rows after wipe: ${AFTER}"
          echo "âœ… Deleted: $((BEFORE - AFTER)) rows"

      - name: "Run: ${{ inputs.action }}"
        run: |
          set -euo pipefail

          ACTION="${{ inputs.action }}"
          SUFFIX="${{ inputs.restore_suffix }}"

          if [[ "$ACTION" == "restore" ]]; then
            PAYLOAD="{\"p_action\": \"${ACTION}\", \"p_restore_suffix\": \"${SUFFIX}\"}"
          else
            PAYLOAD="{\"p_action\": \"${ACTION}\"}"
          fi

          echo "ðŸš€ Calling fn_ingredient_ecosystem with action: $ACTION"

          RESPONSE=$(curl -sfS -X POST "${SUPABASE_URL}/rest/v1/rpc/fn_ingredient_ecosystem" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")

          echo "$RESPONSE" | jq '.' 2>/dev/null || echo "$RESPONSE"

          ACTION_RESULT=$(echo "$RESPONSE" | jq -r '.action' 2>/dev/null)
          if [[ "$ACTION_RESULT" != "$ACTION" ]]; then
            echo "âŒ Unexpected response"
            exit 1
          fi

          echo ""
          echo "âœ… $ACTION complete"
          SUFFIX_OUT=$(echo "$RESPONSE" | jq -r '.suffix // empty' 2>/dev/null)
          if [[ -n "$SUFFIX_OUT" ]]; then
            echo "ðŸ“¦ Backup suffix: $SUFFIX_OUT"
          fi

      - name: Queue Status Summary
        if: ${{ always() }}
        run: |
          echo "=== Ingredient Match Queue Status ==="

          # Optimized: Use count queries with minimal data fetch
          get_count() {
            local filter="$1"
            curl -sI \
              "${SUPABASE_URL}/rest/v1/ingredient_match_queue?select=id&${filter}" \
              -H "apikey: ${SUPABASE_SERVICE_ROLE_KEY}" \
              -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE_KEY}" \
              -H "Prefer: count=exact" \
              -H "Range: 0-0" \
              | grep -i '^content-range' \
              | sed -E 's/.*\/([0-9]+).*/\1/' || echo "0"
          }

          echo "Status breakdown by source:"
          for source in scraper recipe; do
            for status in pending processing success failed; do
              count=$(get_count "source=eq.${source}&status=eq.${status}")
              [ "$count" != "0" ] && echo "  ${source}/${status}: ${count}"
            done
          done

          # Total pending count
          pending_total=$(get_count "status=eq.pending")
          echo "Total pending rows: ${pending_total}"

  initiating-bootstrap:
    name: Full Bootstrap (Initiating Workflow)
    needs: run
    if: ${{ inputs.action == 'backup-and-reset' && inputs.run_initiating_workflow }}
    uses: ./.github/workflows/initiating-workflow.yml
    secrets: inherit
    with:
      queue_resolver_name: "backup-initiating"
      scraper_cities_csv: "San Francisco,Oakland,Berkeley"
      scraper_state: "CA"
      ingredient_limit: "0"
      store_limit: "0"
      queue_batch_limit: "100"
      queue_max_batches: "10"
